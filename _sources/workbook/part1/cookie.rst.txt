==============
Cookie Clicker
==============

Cookie Clicker is a simple game where you click a cookie to get more cookies.
Preview the activity at |cookie_preview|.

.. |cookie_preview| raw:: html

    <a href="https://drafter-edu.github.io/examples/cookie/" target="_blank">
        https://drafter-edu.github.io/examples/cookie/</a>

.. image:: /workbook/part1/cookie.png
    :width: 427
    :align: center
    :alt: Screenshot of the Cookie Clicker game

**Step 1: Download** :download:`cookie.py </workbook/part1/cookie.py>` and put it into an appropriate directory, where you will place all the other files
for this workbook.

The file contains a ``State`` class and two route functions: ``index`` and ``cookie``.
The file also contains three unit tests that you will need to pass; you cannot make alterations
to the unit tests, since they match the instructor tests we are using to grade you.
At the bottom, there is a call to ``start_server``, passing in a ``State`` object with ``cookies`` set to ``0``.
You won't be able to run this file until you have finished implementing ``State`` and the functions.

**Step 2:** Inside the ``State`` field, you will need to create a ``cookies`` field (an integer).
You can remove the "TODO" part of the docstring.

**Step 3:** You will need to define the body of the two routes:

1. The ``index`` route will consume a ``State`` object and return a ``Page``. The ``state`` in the
   returned ``Page`` will be unchanged. The content of the ``Page`` will be (in order):

    - The text ``"You have X cookies"`` except instead of ``X`` it will be the ``cookies`` of the ``State``
      object.
    - A ``Button`` with the text ``"üç™"`` that links to a ``cookie`` route.

2. The ``cookie`` route will consume a ``State`` object and return a ``Page``.
   The ``cookies`` of the ``state`` in the returned ``Page`` will be increased by 1.
   The function should return the result of calling the ``index`` function with the modified ``state``.

**Step 4:** Run the file. You should see a message like the following:

.. code-block::

    TEST PASSED - [line 23] assert_equal(
    TEST PASSED - [line 31] assert_equal(
    TEST PASSED - [line 39] assert_equal(
    Drafter server starting up (using Bottle backend).
    Listening on http://localhost:8080/

    Hit Ctrl-C to quit.

It is possible that you will see an error instead. If you do, read the error message carefully and try to fix the problem.
The application will not start if there are syntax or runtime errors in your code.
However, if you see the message above, you can open a web browser and go to ``http://localhost:8080/`` to see your application.
This will work even if you have not passed the tests yet.

If you see failing tests, then it will be very important to go look at the failing tests and see what they
are expecting. The debug information shown in the browser can actually help you understand what is going wrong.
Scroll down to the bottom of the live webpage.

.. image:: /workbook/part1/cookie_test.png
    :width: 700
    :align: center
    :alt: Screenshot of failing test for the Cookie Clicker game

The **Test Status** section will show a visual representation of the tests that are failing,
with the exact differences highlighted. In the example above, the third test is failing because
the when we called ``cookie(State(cookies=100))`` we expected the result to have ``cookies`` set to ``101``,
but instead the result had ``cookies`` set to ``1``. This was a mistake in the implementation of the ``cookie`` function,
since the function should be increasing the number of cookies by 1 instead of just assigning the value 1.
The correct version of ``cookie`` should look like this:

.. code-block:: python

    @route
    def cookie(state: State) -> Page:
        state.cookies += 1
        return index(state)

This example highlights the two major kinds of routes that you will see:

* routes that **modify** (mutate) the state (like ``cookie``), and
* routes that **do not modify** the state (like ``index``).

Usually, the routes that modify the state will return a new page that is generated by calling another route.
This avoids code duplication and makes it easier to test the routes, since we are reusing the rendering logic of the other routes.
The routes that do not modify the state will usually just return a page with the state as is.

.. mermaid::

    flowchart LR
        start(("Start"))
        index["index"]
        cookie[/"cookie"/]
        start --> index
        index -- "üç™" --> cookie
        cookie -.-> index

The diagram above helps visualize the flow of the application.
When the application starts, the ``index`` route is called.
When the üç™ button is clicked, the ``cookie`` route is called, which increments the number of cookies and then returns
the result of calling the ``index`` route.
We use a dashed arrow to indicate that the ``cookie`` route does not directly return the ``Page`` object, but instead
calls the ``index`` route to get the ``Page`` object.
We use a parallelogram to indicate that the ``cookie`` route modifies the state.
